<html>
<head>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.js"></script>

	<style>
		.draggable {
			outline: none;
		}

		svg {
			touch-action: none;
		}

		body, svg text {
			font: normal 1em Verdana, Helvetica, Arial, sans-serif;
		}
	</style>
</head>

<body>
	<div style="width: 100%; margin: 0; padding: 0; display: inline-block; text-align: center;">
		<svg id="svg" width="800" height="800" ></svg>
	</div>
</body>
<script>

	const SVG = $('#svg');

	function svg(elem, attr) {
	    let e = $(document.createElementNS('http://www.w3.org/2000/svg', elem));
	    if (attr) e.attr(attr);
	    return e;
	}

	SVG.append(svg('rect', {id: 'r1', x: 70, y: 100, width: 600, height: 500, 'stroke-width': 0, fill: 'yellow', opacity: 0.5}));  // area 300_000 sq units
	SVG.append(svg('rect', {id: 'r2', x: 50, y: 50, width: 250, height: 150, 'stroke-width': 0, fill: 'blue', opacity: 0.2}));  // area 37_500 sq units
	SVG.append(svg('rect', {id: 'r3', x: 300, y: 300, width: 100, height: 200, 'stroke-width': 0, fill: 'salmon', opacity: 0.2})); // area 20_000 sq units
	SVG.append(svg('rect', {id: 'r4', x: 500, y: 300, width: 200, height: 100, 'stroke-width': 0, fill: 'salmon', opacity: 0.2})); // area 20_000 sq units
	SVG.append(svg('circle', {id: 'c1', cx: 650, cy: 150, r: 100, 'stroke-width': 0, opacity: 0.2})); // area 31_416 sq px

	function distancePointToLine(line, p0) { // signed
		// https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
		let num = (line.x2 - line.x1) * (line.y1 - p0.y) - (line.x1 - p0.x) * (line.y2 - line.y1);
		return num / Math.hypot(line.x2 - line.x1, line.y2 - line.y1);
	}

	class Tracker {
		constructor(item) {
			this.q = [];
		}

		push(item) {
			if      (this.q.length == 0) this.q.push(item);
			else if (this.q.length == 2) this.q.shift();

			this.q.push(item);
		}

		clear() {
			this.q = [];
		}
	}

	class TrackerXY extends Tracker {
		get dx() {
			return this.q[1].x - this.q[0].x;
		}

		get dy() {
			return this.q[1].y - this.q[0].y;
		}
	}

	class Planimeter {
		// https://www.tandfonline.com/doi/full/10.1080/07468342.2020.1702852
		// http://whistleralley.com/planimeter/planimeter.htm

		constructor() {
			this.pole = new DraggableCircle('POLE', 'pole', {cx: 400, cy: 200, r: 220, stroke: 'blue', 'fill-opacity': 0.3, fill: '#BBBBEE'});

			this.tracer = new DraggableCircle('TRACER', 'tracer', {cx: 200, cy: 400, r: 200, stroke: 'green', 'fill-opacity': 0.3, fill: '#BBEEBB'});

			SVG.append(svg('circle', {cx: 0, cy: 0, r: 2.5, id: 'pivot'}));

			SVG.append(svg('polyline', {id: 'arms', points: '0,0, 0,0', fill: 'none', stroke: 'red', 'stroke-width': 1, opacity: 0.3}));

			this.tracerArmTracker = new Tracker();

			this.zeroise();

			this.linkage();

			this.C = Math.PI * (this.pole.r ** 2 + this.tracer.r ** 2);

			$(this.pole.text).text(`pole, C=${this.C.toFixed(1)}`);



		}


		zeroise() {
			this.distanceRolled = 0;
			this.setTracerText('tracer: 0 sq units')
			return;
		}

		setTracerText(t) {
			$('#TRACER').prev('circle').prev('text').text(t);
		}

		intersectionPoints() { // intersection points of POLE and TRACER circles
			// https://www.petercollingridge.co.uk/tutorials/computational-geometry/circle-circle-intersections/
			// http://www.ambrsoft.com/TrigoCalc/Circles2/circle2intersection/CircleCircleIntersection.htm

		    const d = Math.hypot(this.pole.current.x - this.tracer.current.x, this.pole.current.y - this.tracer.current.y); // distance between centers

		    let res = {d, intersect: false};

			if (d > this.pole.r + this.tracer.r) return res; // too far apart

			if (d < Math.abs(this.pole.r - this.tracer.r)) return res; // One circle completely inside the other

			res.intersect = true;

		    let dx = (this.tracer.current.x - this.pole.current.x) / d; // unit vectors for one center to the other
		    let dy = (this.tracer.current.y - this.pole.current.y) / d;

			// calculate where line through intersection points crosses line through centers
			const a = (this.pole.r * this.pole.r - this.tracer.r * this.tracer.r + d * d) / (2 * d);
			let px = this.pole.current.x + a * dx;
			let py = this.pole.current.y + a * dy;

			const h = Math.sqrt(this.pole.r * this.pole.r - a * a); // height of intersection line

			// Calculate the intersection points by moving h units up and down from p,
			// perpendicular to the line between the circle centers.
			res['p1'] = {x: px + h * dy, y: py - h * dx};
			res['p2'] = {x: px - h * dy, y: py + h * dx};

			return res;
		}

		linkage() {
			let intersect = this.intersectionPoints();

			if (! intersect.intersect) {
				$('#pivot, #arms').attr({display: 'none'});
				return;
			}

			let ip = intersect.p1;

			this.tracerArmTracker.push({x1: ip.x, y1: ip.y, x2: this.tracer.current.x, y2: this.tracer.current.y});

			this.calculateRoll();

			$('#pivot').attr({cx: ip.x, cy: ip.y, display: 'visible'});
			$('#arms').attr({points: `${this.pole.current.x},${this.pole.current.y}  ${ip.x},${ip.y}  ${this.tracer.current.x},${this.tracer.current.y}`, display: 'visible'});
		}

		calculateRoll() {
			let [prev, curr] = this.tracerArmTracker.q; // previous and current x1,y1 for pivot and x2,y2 for tracer

			let d = distancePointToLine(prev, {x: curr.x1, y: curr.y1});

			this.distanceRolled -= d * this.tracer.r;

			this.setTracerText(`tracer: ${this.distanceRolled.toFixed(2)} sq units`)
		}
	}

	class DraggableCircle {

		static LABEL_LEAD = 7;

		constructor(id, text, params) {
			this.id = id;
			this.r = params.r;
			this.current = {x: params.cx, y: params.cy};
			this.moveTrack = new TrackerXY();

			this.text = svg('text', {x: params.cx + DraggableCircle.LABEL_LEAD, y: params.cy, style: 'font-size: smaller;'}).text(text);

			this.small = svg('circle', {cx: params.cx, cy: params.cy, r: 5, fill: 'orange', opacity: 0.4});

			this.large = svg('circle', Object.assign({id, class: 'draggable', tabindex: 0}, params));

			SVG.append(this.text);
			SVG.append(this.small);
			SVG.append(this.large);

			$(this.large).data('instance', this);
		}

		move(dx, dy) {
			let newX = this.current.x + dx;
			let newY = this.current.y + dy;

			$(this.large).attr({cx: newX, cy: newY});
			$(this.small).attr({cx: newX, cy: newY});
			$(this.text).attr({x: newX + DraggableCircle.LABEL_LEAD, y: newY});

			this.current = {x: newX, y: newY};

			PLANIMETER.linkage();
		}
	}

	const PLANIMETER = new Planimeter();



	$(document).on('keypress keydown', '.draggable', keyHandler);

	function keyHandler(event) {
		if (['z', 'Z', '0'].includes(event.key)) {
			PLANIMETER.zeroise();
			return;
		}

		let dy = dx = 0;

		if      (event.key == 'ArrowUp')    dy = -1;
		else if (event.key == 'ArrowDown')  dy = +1;
		else if (event.key == 'ArrowLeft')  dx = -1;
		else if (event.key == 'ArrowRight') dx = +1;
		else return;

		event.preventDefault();

		if (event.shiftKey) {
			dy *= 10;
			dx *= 10;
		}

		let sel = $('#' + $(this).attr('id'));
		let instance = sel.data('instance');
		instance.move(dx, dy);
	}

	function calc() {
		return PLANIMETER.C + PLANIMETER.distanceRolled;
	}

	function dragHandler(event) {
		let sel = $('#' + event.target.id);
		let instance = sel.data('instance');
		instance.move(event.dx, event.dy);
	}

	interact('.draggable').draggable({listeners: {move: dragHandler}});

	interact('#TRACER').on('doubletap', event => PLANIMETER.zeroise());

	function goto(x, y) {
		let t = PLANIMETER.tracer;

		t.move(x - t.current.x, y - t.current.y);
	}


	function traceRect(id) {
		if ($(id)[0].localName != 'rect') return;

		let x  = parseFloat($(id).attr('x'))
		let y  = parseFloat($(id).attr('y'))
		let h  = parseFloat($(id).attr('height'))
		let w  = parseFloat($(id).attr('width'))

		console.log(id, x, y, h, w)

		goto(x, y)

		PLANIMETER.zeroise()

		let delta = 0.01
		let tx = x;
		let ty = y;

		for (; tx <= x + w; tx += delta) { // top, left to rright
			goto(tx, ty)
		}

		for (; ty <= y + h; ty += delta) { // rhs, top to bottom
			goto(tx, ty)
		}

		for (; tx >= x; tx -= delta) {// bottom, right to left
			goto(tx, ty)
		}

		for (; ty >= y; ty -= delta) {// lhs, bottom to top
			goto(tx, ty)
		}

		console.log(`got ${PLANIMETER.distanceRolled.toFixed(2)}, expected ${(h * w).toFixed(2)}`)
	}

	function traceCircle(id) {
		if ($(id)[0].localName != 'circle') return;

		let cx  = parseFloat($(id).attr('cx'))
		let cy  = parseFloat($(id).attr('cy'))
		let r   = parseFloat($(id).attr('r'))

		console.log(id, cx, cy, r)

		goto(cx - r, cy)

		PLANIMETER.zeroise()

		for (let theta = 0; theta <= 2 * Math.PI; theta += 0.001) {
			goto(cx - r * Math.cos(theta), cy - r * Math.sin(theta))
		}

		console.log(`got ${PLANIMETER.distanceRolled.toFixed(2)}, expected ${(Math.PI * r * r).toFixed(2)}`)
	}

</script>

</html>