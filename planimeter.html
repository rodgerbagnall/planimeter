<html>
<head>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.js"></script>

	<style>
		.draggable {
			outline: none;
		}

		svg {
			touch-action: none;
		}

		body, svg text {
			font: normal 1em Verdana, Helvetica, Arial, sans-serif;
		}
	</style>
</head>

<body>
	<div style="width: 100%; margin: 0; padding: 0; display: inline-block; text-align: center;">
		<svg id="svg" width="800" height="800" ></svg>
	</div>
</body>
<script>

	const SVG = $('#svg');

	function svg(elem, attr) {
	    let e = $(document.createElementNS('http://www.w3.org/2000/svg', elem));
	    if (attr) e.attr(attr);
	    return e;
	}

	SVG.append(svg('rect', {class: 'traceable', id: 'r1', x: 70, y: 100, width: 600, height: 500, 'stroke-width': 0, fill: 'yellow', opacity: 0.5}));  // area 300_000 sq units
	SVG.append(svg('rect', {class: 'traceable', id: 'r2', x: 50, y: 50, width: 250, height: 150, 'stroke-width': 0, fill: 'blue', opacity: 0.2}));  // area 37_500 sq units
	SVG.append(svg('rect', {class: 'traceable', id: 'r3', x: 300, y: 300, width: 100, height: 200, 'stroke-width': 0, fill: 'salmon', opacity: 0.2})); // area 20_000 sq units
	SVG.append(svg('rect', {class: 'traceable', id: 'r4', x: 500, y: 300, width: 200, height: 100, 'stroke-width': 0, fill: 'salmon', opacity: 0.2})); // area 20_000 sq units
	SVG.append(svg('circle', {class: 'traceable', id: 'c1', cx: 650, cy: 150, r: 100, 'stroke-width': 0, opacity: 0.2})); // area 31_416 sq units
	SVG.append(svg('polygon', {class: 'traceable', id: 'p1', points: '100,300 120,260 140,300 120,340', 'stroke-width': 0, opacity: 0.2})); // area 1600 sq units
	SVG.append(svg('polygon', {class: 'traceable', id: 'p2', points: '300,500 270,550 300,570 200,560 150,550 100,500 200,450 250,500', 'stroke-width': 0, opacity: 0.2})); // area 13_200 sq units
	SVG.append(svg('polygon', {class: 'traceable', id: 'p3', points: '500,410 650,410 650,550 640,550 640,480 500,480', 'stroke-width': 1, stroke: 'black', opacity: 0.2})); // area 11_200 sq units

	function distancePointToLine(line, p0) { // signed
		// https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
		let num = (line.x2 - line.x1) * (line.y1 - p0.y) - (line.x1 - p0.x) * (line.y2 - line.y1);
		return num / Math.hypot(line.x2 - line.x1, line.y2 - line.y1);
	}

	class Tracker {
		constructor(item) {
			this.q = [];
		}

		push(item) {
			if      (this.q.length == 0) this.q.push(item);
			else if (this.q.length == 2) this.q.shift();

			this.q.push(item);
		}

		clear() {
			this.q = [];
		}
	}

	class TrackerXY extends Tracker {
		get dx() {
			return this.q[1].x - this.q[0].x;
		}

		get dy() {
			return this.q[1].y - this.q[0].y;
		}
	}

	class Planimeter {
		// https://www.tandfonline.com/doi/full/10.1080/07468342.2020.1702852
		// http://whistleralley.com/planimeter/planimeter.htm

		constructor() {
			this.pole = new DraggableCircle('POLE', 'pole', {cx: 400, cy: 200, r: 220, stroke: 'blue', 'fill-opacity': 0.3, fill: '#BBBBEE'});

			this.tracer = new DraggableCircle('TRACER', 'tracer', {cx: 200, cy: 400, r: 200, stroke: 'green', 'fill-opacity': 0.3, fill: '#BBEEBB'});

			SVG.append(svg('circle', {cx: 0, cy: 0, r: 2.5, id: 'pivot'}));

			SVG.append(svg('polyline', {id: 'arms', points: '0,0, 0,0', fill: 'none', stroke: 'red', 'stroke-width': 1, opacity: 0.3}));

			this.tracerArmTracker = new Tracker();

			this.zeroise();

			this.linkage();

			this.C = Math.PI * (this.pole.r ** 2 + this.tracer.r ** 2);

			$(this.pole.text).text(`pole, C=${this.C.toFixed(1)}`);



		}

		zeroise() {
			this.distanceRolled = 0;
			this.setTracerText('tracer: 0 sq units')
			return;
		}

		goto(x, y) {
			let t = this.tracer;

			t.move(x - t.current.x, y - t.current.y);
		}

		setTracerText(t) {
			$('#TRACER').prev('circle').prev('text').text(t);
		}

		intersectionPoints() { // intersection points of POLE and TRACER circles
			// https://www.petercollingridge.co.uk/tutorials/computational-geometry/circle-circle-intersections/
			// http://www.ambrsoft.com/TrigoCalc/Circles2/circle2intersection/CircleCircleIntersection.htm

		    const d = Math.hypot(this.pole.current.x - this.tracer.current.x, this.pole.current.y - this.tracer.current.y); // distance between centers

		    let res = {d, intersect: false};

			if (d > this.pole.r + this.tracer.r) return res; // too far apart

			if (d < Math.abs(this.pole.r - this.tracer.r)) return res; // One circle completely inside the other

			res.intersect = true;

		    let dx = (this.tracer.current.x - this.pole.current.x) / d; // unit vectors for one center to the other
		    let dy = (this.tracer.current.y - this.pole.current.y) / d;

			// calculate where line through intersection points crosses line through centers
			const a = (this.pole.r * this.pole.r - this.tracer.r * this.tracer.r + d * d) / (2 * d);
			let px = this.pole.current.x + a * dx;
			let py = this.pole.current.y + a * dy;

			const h = Math.sqrt(this.pole.r * this.pole.r - a * a); // height of intersection line

			// Calculate the intersection points by moving h units up and down from p,
			// perpendicular to the line between the circle centers.
			res['p1'] = {x: px + h * dy, y: py - h * dx};
			res['p2'] = {x: px - h * dy, y: py + h * dx};

			return res;
		}

		linkage() {
			let intersect = this.intersectionPoints();

			if (! intersect.intersect) {
				$('#pivot, #arms').attr({display: 'none'});
				return;
			}

			let ip = intersect.p1;

			this.tracerArmTracker.push({x1: ip.x, y1: ip.y, x2: this.tracer.current.x, y2: this.tracer.current.y});

			this.calculateRoll();

			$('#pivot').attr({cx: ip.x, cy: ip.y, display: 'visible'});
			$('#arms').attr({points: `${this.pole.current.x},${this.pole.current.y}  ${ip.x},${ip.y}  ${this.tracer.current.x},${this.tracer.current.y}`, display: 'visible'});
		}

		calculateRoll() {
			let [prev, curr] = this.tracerArmTracker.q; // previous and current x1,y1 for pivot and x2,y2 for tracer

			let d = distancePointToLine(prev, {x: curr.x1, y: curr.y1});

			this.distanceRolled -= d * this.tracer.r;

			this.setTracerText(`tracer: ${this.distanceRolled.toFixed(2)} sq units`)
		}
	}

	class DraggableCircle {

		static LABEL_LEAD = 7;

		constructor(id, text, params) {
			this.id = id;
			this.r = params.r;
			this.current = {x: params.cx, y: params.cy};
			this.moveTrack = new TrackerXY();

			this.text = svg('text', {x: params.cx + DraggableCircle.LABEL_LEAD, y: params.cy, style: 'font-size: smaller;'}).text(text);

			this.small = svg('circle', {cx: params.cx, cy: params.cy, r: 5, fill: 'orange', opacity: 0.4});

			this.large = svg('circle', Object.assign({id, class: 'draggable', tabindex: 0}, params));

			SVG.append(this.text);
			SVG.append(this.small);
			SVG.append(this.large);

			$(this.large).data('instance', this);
		}

		move(dx, dy) {
			let newX = this.current.x + dx;
			let newY = this.current.y + dy;

			$(this.large).attr({cx: newX, cy: newY});
			$(this.small).attr({cx: newX, cy: newY});
			$(this.text).attr({x: newX + DraggableCircle.LABEL_LEAD, y: newY});

			this.current = {x: newX, y: newY};

			PLANIMETER.linkage();
		}
	}

	const PLANIMETER = new Planimeter();



	$(document).on('keypress keydown', '.draggable', keyHandler);

	function keyHandler(event) {
		if (['z', 'Z', '0'].includes(event.key)) {
			PLANIMETER.zeroise();
			return;
		}

		let dy = dx = 0;

		if      (event.key == 'ArrowUp')    dy = -1;
		else if (event.key == 'ArrowDown')  dy = +1;
		else if (event.key == 'ArrowLeft')  dx = -1;
		else if (event.key == 'ArrowRight') dx = +1;
		else return;

		event.preventDefault();

		if (event.shiftKey) {
			dy *= 10;
			dx *= 10;
		}

		let sel = $('#' + $(this).attr('id'));
		let instance = sel.data('instance');
		instance.move(dx, dy);
	}

	function calc() {
		return PLANIMETER.C + PLANIMETER.distanceRolled;
	}

	function dragHandler(event) {
		let sel = $('#' + event.target.id);
		let instance = sel.data('instance');
		instance.move(event.dx, event.dy);
	}

	interact('.draggable').draggable({listeners: {move: dragHandler}});

	interact('#TRACER').on('doubletap', event => PLANIMETER.zeroise());

	function sleep(ms) {
		return new Promise(resolve => setTimeout(resolve, ms));
	}

	class Line {
		constructor(p1, p2) {
			this.p1 = p1;
			this.p2 = p2;

			this.m = (p2.y - p1.y) / (p2.x - p1.x);

			if (Math.abs(this.m) != Infinity) this.c = p1.y - p1.x * this.m;
		}

		y(x) {
			return this.m * x + this.c;
		}

		x(y) {
			return (y - this.c) / this.m;
		}

		* points(delta) {
			if (Math.abs(this.m) == Infinity) { // vertical
				if (this.p2.y  > this.p1.y) {
					for (let y = this.p1.y; y <= this.p2.y; y += delta) {
						yield {x: this.p1.x, y};
					}
				} else {
					for (let y = this.p1.y; y >= this.p2.y; y -= delta) {
						yield {x: this.p1.x, y};
					}
				}
			} else if (Math.abs(this.m) <= 1) { // shallow
				if (this.p2.x > this.p1.x) {
					for (let x = this.p1.x; x <= this.p2.x; x += delta) {
						yield {x, y: this.y(x)};
					}
				} else {
					for (let x = this.p1.x; x >= this.p2.x; x -= delta) {
						yield {x, y: this.y(x)};
					}
				}
			} else { // steep
				if (this.p2.y  > this.p1.y) {
					for (let y = this.p1.y; y <= this.p2.y; y += delta) {
						yield {x: this.x(y), y};
					}
				} else {
					for (let y = this.p1.y; y >= this.p2.y; y -= delta) {
						yield {x: this.x(y), y};
					}
				}
			}
		}

	}

	async function trace(event) {
		let id = '#' + event.currentTarget.id;
		let localName = $(id)[0].localName;
		console.log(localName)
		if (localName == 'rect') traceRect(id);
		else if (localName == 'circle') traceCircle(id);
		else if (localName == 'polygon') tracePolygon(id);
		else console.err(`can only trace rectangles, polygons or circles, not ${localName}s`);
	}


	async function traceRect(id) {
		let x  = parseFloat($(id).attr('x'))
		let y  = parseFloat($(id).attr('y'))
		let h  = parseFloat($(id).attr('height'))
		let w  = parseFloat($(id).attr('width'))

		PLANIMETER.goto(x, y);
		PLANIMETER.zeroise();
		await sleep(700);

		let delta = 0.001, step = 0, major = 250, ms = 10;

		let lines = [
			new Line({x, y}, {x: x + w, y}),
			new Line({x: x + w, y}, {x: x + w, y: y + h}),
			new Line({x: x + w, y: y + h}, {x, y: y + h}),
			new Line({x, y: y + h}, {x, y})
		];

		for (line of lines) {
			for (let p of line.points(delta)) {
				PLANIMETER.goto(p.x, p.y);
				if (step++ % major == 0) await(sleep(ms));
			}
		}

		console.log(`got ${PLANIMETER.distanceRolled.toFixed(2)}, expected ${(h * w).toFixed(2)}`);
	}

	async function traceCircle(id) {
		let cx  = parseFloat($(id).attr('cx'));
		let cy  = parseFloat($(id).attr('cy'));
		let r   = parseFloat($(id).attr('r'));

		PLANIMETER.goto(cx - r, cy);
		PLANIMETER.zeroise();
		await sleep(700);

		let delta = 0.001, step = 0, major = 100, ms = 25;

		for (let theta = 0; theta <= 2 * Math.PI; theta += delta) {
			PLANIMETER.goto(cx - r * Math.cos(theta), cy - r * Math.sin(theta));
			if (step++ % major == 0) await(sleep(ms));
		}

		console.log(`got ${PLANIMETER.distanceRolled.toFixed(2)}, expected ${(Math.PI * r * r).toFixed(2)}`);
	}

	async function tracePolygon(id) {
		let points = $(id).attr('points').split(' '), n = points.length;

		for (let i = 0; i < n; i++) {
			let [x, y] = points[i].split(',');
			points[i] = {x: parseFloat(x), y: parseFloat(y)}
		}

		points.push(points[0])

		let area = 0;

		for (let i = 0; i < n; i++) {
			area += (points[i].x - points[i + 1].x) * (points[i].y + points[i + 1].y) / 2
		}

		PLANIMETER.goto(points[0].x, points[0].y);
		PLANIMETER.zeroise();
		await sleep(700);

		let delta = 0.001, step = 0, major = 400, ms = 5;

		for (let i = 0; i < n; i++) {
			let line = new Line(points[i], points[i + 1]);

			for (let p of line.points(delta)) {
				PLANIMETER.goto(p.x, p.y);
				if (step++ % major == 0) await(sleep(ms));
			}
		}

		console.log(`got ${PLANIMETER.distanceRolled.toFixed(2)}, expected ${area.toFixed(2)}`);
	}


	interact('.traceable').on('tap', event => trace(event));


</script>

</html>